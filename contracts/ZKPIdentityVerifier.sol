// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * ZKPIdentityVerifier.sol
 * 
 * Digital Legacy Vault - Phase 2: ZKP Verification Layer
 * Built by Brad Powell / Elev8.AI Consulting & Integration
 * 
 * This contract verifies zero-knowledge proofs that a beneficiary's
 * identity matches the hash stored in the vault smart contract.
 * 
 * The beneficiary proves: "I know (DID, nonce) such that
 * Poseidon(DID, nonce) = identity_hash" without revealing DID or nonce.
 * 
 * ARCHITECTURE:
 *   - Wraps a Groth16 verifier (auto-generated by snarkjs from the circuit)
 *   - Adds domain-specific checks (vault binding, timestamp freshness)
 *   - Called by DigitalLegacyVaultV2.initiateClaim()
 * 
 * DEPLOYMENT:
 *   1. Deploy Groth16Verifier (snarkjs-generated)
 *   2. Deploy ZKPIdentityVerifier with Groth16Verifier address
 *   3. Set as verifier in DigitalLegacyVaultV2
 */

// ============================================================
// GROTH16 VERIFIER INTERFACE
// ============================================================

/**
 * Interface for the auto-generated Groth16 verifier contract.
 * snarkjs generates this with: snarkjs zkey export solidityverifier
 * 
 * The proof consists of elliptic curve points on BN128:
 *   - pA: point on G1 (2 uint256)
 *   - pB: point on G2 (2x2 uint256) 
 *   - pC: point on G1 (2 uint256)
 *   - pubSignals: array of public inputs/outputs
 */
interface IGroth16Verifier {
    function verifyProof(
        uint[2] calldata _pA,
        uint[2][2] calldata _pB,
        uint[2] calldata _pC,
        uint[5] calldata _pubSignals  // [identity_hash, vault_owner, claim_timestamp, min_timestamp, claim_binding]
    ) external view returns (bool);
}


// ============================================================
// MAIN VERIFIER CONTRACT
// ============================================================

contract ZKPIdentityVerifier {

    // --------------------------------------------------------
    // STATE
    // --------------------------------------------------------

    IGroth16Verifier public immutable groth16Verifier;
    address public admin;

    // Anti-replay: track used proof nullifiers
    // key: keccak256(vault_owner, claim_binding)
    mapping(bytes32 => bool) public usedProofs;

    // Timestamp tolerance: proof must be within this window
    uint256 public constant PROOF_FRESHNESS_WINDOW = 1 hours;

    // Maximum age of min_timestamp (prevents ancient proofs)
    uint256 public constant MAX_TIMESTAMP_AGE = 24 hours;


    // --------------------------------------------------------
    // EVENTS
    // --------------------------------------------------------

    event ProofVerified(
        address indexed vaultOwner,
        address indexed beneficiary,
        uint256 claimTimestamp,
        bytes32 claimBinding
    );

    event ProofRejected(
        address indexed vaultOwner,
        address indexed beneficiary,
        string reason
    );


    // --------------------------------------------------------
    // ERRORS
    // --------------------------------------------------------

    error InvalidGroth16Proof();
    error ProofAlreadyUsed();
    error ProofExpired();
    error TimestampMismatch();
    error IdentityHashMismatch();
    error VaultOwnerMismatch();
    error InvalidMinTimestamp();


    // --------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------

    /**
     * @param _groth16Verifier Address of the snarkjs-generated Groth16 verifier
     */
    constructor(address _groth16Verifier) {
        require(_groth16Verifier != address(0), "Invalid verifier address");
        groth16Verifier = IGroth16Verifier(_groth16Verifier);
        admin = msg.sender;
    }


    // --------------------------------------------------------
    // CORE VERIFICATION
    // --------------------------------------------------------

    /**
     * @notice Verify a ZKP identity proof for a vault claim
     * 
     * @param _vaultOwner       Address of the vault being claimed
     * @param _identityHash     The identity hash stored in the vault contract
     * @param _pA               Groth16 proof point A (G1)
     * @param _pB               Groth16 proof point B (G2)
     * @param _pC               Groth16 proof point C (G1)
     * @param _pubSignals       Public signals: [identity_hash, vault_owner_uint, claim_timestamp, min_timestamp, claim_binding]
     * 
     * @return valid            Whether the proof is valid
     * @return claimBinding     The claim binding hash (for on-chain logging)
     * 
     * VERIFICATION STEPS:
     *   1. Check public signal[0] matches the on-chain identity_hash
     *   2. Check public signal[1] matches the vault_owner address
     *   3. Check claim_timestamp is fresh (within PROOF_FRESHNESS_WINDOW)
     *   4. Check min_timestamp is reasonable
     *   5. Check proof hasn't been used before (anti-replay)
     *   6. Verify the Groth16 proof cryptographically
     *   7. Mark proof as used
     */
    function verifyIdentityProof(
        address _vaultOwner,
        bytes32 _identityHash,
        uint[2] calldata _pA,
        uint[2][2] calldata _pB,
        uint[2] calldata _pC,
        uint[5] calldata _pubSignals
    ) external returns (bool valid, bytes32 claimBinding) {
        
        // ---- Step 1: Identity hash matches on-chain value ----
        if (bytes32(_pubSignals[0]) != _identityHash) {
            emit ProofRejected(_vaultOwner, msg.sender, "Identity hash mismatch");
            revert IdentityHashMismatch();
        }

        // ---- Step 2: Vault owner matches ----
        if (address(uint160(_pubSignals[1])) != _vaultOwner) {
            emit ProofRejected(_vaultOwner, msg.sender, "Vault owner mismatch");
            revert VaultOwnerMismatch();
        }

        // ---- Step 3: Timestamp freshness ----
        uint256 claimTimestamp = _pubSignals[2];
        if (block.timestamp > claimTimestamp + PROOF_FRESHNESS_WINDOW) {
            emit ProofRejected(_vaultOwner, msg.sender, "Proof expired");
            revert ProofExpired();
        }
        if (claimTimestamp > block.timestamp + 5 minutes) {
            // Proof claims to be from the future (clock skew tolerance: 5 min)
            emit ProofRejected(_vaultOwner, msg.sender, "Timestamp in future");
            revert TimestampMismatch();
        }

        // ---- Step 4: Min timestamp sanity ----
        uint256 minTimestamp = _pubSignals[3];
        if (block.timestamp > minTimestamp + MAX_TIMESTAMP_AGE) {
            emit ProofRejected(_vaultOwner, msg.sender, "Min timestamp too old");
            revert InvalidMinTimestamp();
        }

        // ---- Step 5: Anti-replay ----
        claimBinding = bytes32(_pubSignals[4]);
        bytes32 nullifier = keccak256(abi.encodePacked(_vaultOwner, claimBinding));
        if (usedProofs[nullifier]) {
            emit ProofRejected(_vaultOwner, msg.sender, "Proof already used");
            revert ProofAlreadyUsed();
        }

        // ---- Step 6: Cryptographic verification ----
        bool proofValid = groth16Verifier.verifyProof(_pA, _pB, _pC, _pubSignals);
        if (!proofValid) {
            emit ProofRejected(_vaultOwner, msg.sender, "Invalid Groth16 proof");
            revert InvalidGroth16Proof();
        }

        // ---- Step 7: Mark as used ----
        usedProofs[nullifier] = true;

        emit ProofVerified(_vaultOwner, msg.sender, claimTimestamp, claimBinding);

        return (true, claimBinding);
    }


    // --------------------------------------------------------
    // VIEW FUNCTIONS
    // --------------------------------------------------------

    /**
     * @notice Check if a proof nullifier has been used
     * @param _vaultOwner   Vault owner address
     * @param _claimBinding Claim binding from the proof
     */
    function isProofUsed(
        address _vaultOwner, 
        bytes32 _claimBinding
    ) external view returns (bool) {
        bytes32 nullifier = keccak256(abi.encodePacked(_vaultOwner, _claimBinding));
        return usedProofs[nullifier];
    }

    /**
     * @notice Get the current freshness window configuration
     */
    function getConfig() external pure returns (
        uint256 freshnessWindow,
        uint256 maxTimestampAge
    ) {
        return (PROOF_FRESHNESS_WINDOW, MAX_TIMESTAMP_AGE);
    }
}


// ============================================================
// MOCK GROTH16 VERIFIER (for testing)
// ============================================================

/**
 * MockGroth16Verifier
 * 
 * Test double that accepts/rejects proofs based on a flag.
 * In production, this is replaced by the snarkjs-generated verifier.
 * 
 * USAGE IN TESTS:
 *   const mock = await MockGroth16Verifier.deploy();
 *   await mock.setShouldVerify(true);  // proofs pass
 *   await mock.setShouldVerify(false); // proofs fail
 */
contract MockGroth16Verifier is IGroth16Verifier {
    
    bool public shouldVerify = true;
    address public admin;
    
    constructor() {
        admin = msg.sender;
    }
    
    function setShouldVerify(bool _should) external {
        require(msg.sender == admin, "Only admin");
        shouldVerify = _should;
    }
    
    function verifyProof(
        uint[2] calldata,
        uint[2][2] calldata,
        uint[2] calldata,
        uint[5] calldata
    ) external view override returns (bool) {
        return shouldVerify;
    }
}
