/**
 * vault-client.js — Blockchain Interaction Layer
 * 
 * Digital Legacy Vault - Smart Contract Client
 * Built by Brad Powell / Elev8.AI Consulting & Integration
 * 
 * Wraps ethers.js to provide a clean API for the React frontend
 * to interact with the DigitalLegacyVault smart contract on Polygon.
 * 
 * Usage:
 *   const client = new VaultClient();
 *   await client.connect();
 *   await client.createVault(ownerDID, 90, 60, 3);
 *   await client.checkIn();
 */

import { ethers } from "ethers";

// ============================================================
// CONTRACT ABI (Subset — full ABI generated by Hardhat compile)
// ============================================================

const VAULT_ABI = [
  // Vault Creation
  "function createVault(bytes32 _ownerDID, uint256 _checkInInterval, uint256 _gracePeriod, uint8 _requiredGuardians) external",
  
  // Check-In
  "function checkIn() external",
  
  // Guardian Management
  "function addGuardian(address _guardian, bytes32 _shareHash) external",
  "function setBeneficiary(address _beneficiary, bytes32 _identityHash) external",
  
  // Content Archive
  "function addContentArchive(string calldata _cid) external",
  
  // State Transitions
  "function evaluateVaultState(address vaultOwner) external",
  "function submitDeathCertificate(address vaultOwner, bytes32 certificateHash, bytes calldata proof) external",
  
  // Claim Process
  "function initiateClaim(address vaultOwner, bytes calldata zkProof) external",
  "function confirmShareRelease(address vaultOwner) external",
  
  // Vault Management
  "function revokeVault() external",
  
  // View Functions
  "function getVaultState(address owner) external view returns (uint8)",
  "function getTimeSinceCheckIn(address owner) external view returns (uint256)",
  "function getGuardianConfirmations(address owner) external view returns (uint8 confirmed, uint8 required)",
  "function getContentArchives(address owner) external view returns (string[] memory)",
  "function isClaimable(address owner) external view returns (bool)",
  "function hasVault(address) external view returns (bool)",
  
  // Constants
  "function MIN_CHECK_IN_INTERVAL() external view returns (uint256)",
  "function MAX_CHECK_IN_INTERVAL() external view returns (uint256)",
  "function MIN_GRACE_PERIOD() external view returns (uint256)",
  
  // Events
  "event VaultCreated(address indexed owner, uint256 checkInInterval, uint8 requiredGuardians)",
  "event CheckIn(address indexed owner, uint256 timestamp)",
  "event StateChanged(address indexed owner, uint8 oldState, uint8 newState)",
  "event GuardianAdded(address indexed owner, address indexed guardian, uint8 index)",
  "event GuardianConfirmed(address indexed owner, address indexed guardian)",
  "event BeneficiarySet(address indexed owner, address indexed beneficiary)",
  "event ClaimInitiated(address indexed owner, address indexed beneficiary, uint8 method)",
  "event SharesReleased(address indexed owner, address indexed beneficiary)",
  "event VaultRevoked(address indexed owner)",
  "event ContentArchiveAdded(address indexed owner, string cid)",
  "event DeathCertificateVerified(address indexed owner, bytes32 certHash, uint256 confidence)",
];

// ============================================================
// NETWORK CONFIGURATION
// ============================================================

const NETWORKS = {
  polygon: {
    chainId: 137,
    name: "Polygon Mainnet",
    rpcUrl: "https://polygon-rpc.com",
    explorer: "https://polygonscan.com",
    currency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
  },
  polygon_amoy: {
    chainId: 80002,
    name: "Polygon Amoy Testnet",
    rpcUrl: "https://rpc-amoy.polygon.technology",
    explorer: "https://amoy.polygonscan.com",
    currency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
  },
  localhost: {
    chainId: 31337,
    name: "Hardhat Local",
    rpcUrl: "http://127.0.0.1:8545",
    explorer: "",
    currency: { name: "ETH", symbol: "ETH", decimals: 18 },
  },
};

// Vault states mapping
const VAULT_STATES = {
  0: "Active",
  1: "Warning",
  2: "Claimable",
  3: "Claimed",
  4: "Revoked",
};

// ============================================================
// VAULT CLIENT CLASS
// ============================================================

class VaultClient {
  constructor(contractAddress, network = "polygon_amoy") {
    this.contractAddress = contractAddress;
    this.network = NETWORKS[network] || NETWORKS.polygon_amoy;
    this.provider = null;
    this.signer = null;
    this.contract = null;
    this.readOnlyContract = null;
    this.connected = false;
    this.address = null;
  }

  // ─── CONNECTION ───

  /**
   * Connect to wallet (MetaMask or compatible)
   * @returns {Promise<string>} Connected wallet address
   */
  async connect() {
    if (!window.ethereum) {
      throw new Error("No wallet detected. Install MetaMask or a compatible wallet.");
    }

    // Request account access
    const accounts = await window.ethereum.request({
      method: "eth_requestAccounts",
    });

    if (!accounts || accounts.length === 0) {
      throw new Error("No accounts found. Please unlock your wallet.");
    }

    // Check/switch network
    await this._ensureNetwork();

    // Setup provider and signer
    this.provider = new ethers.BrowserProvider(window.ethereum);
    this.signer = await this.provider.getSigner();
    this.address = await this.signer.getAddress();

    // Initialize contract instances
    this.contract = new ethers.Contract(
      this.contractAddress,
      VAULT_ABI,
      this.signer
    );
    this.readOnlyContract = new ethers.Contract(
      this.contractAddress,
      VAULT_ABI,
      this.provider
    );

    this.connected = true;

    // Listen for account/network changes
    window.ethereum.on("accountsChanged", (accounts) => {
      if (accounts.length === 0) {
        this.connected = false;
        this.address = null;
      } else {
        this.address = accounts[0];
      }
    });

    window.ethereum.on("chainChanged", () => {
      window.location.reload();
    });

    return this.address;
  }

  /**
   * Ensure we're on the correct network
   */
  async _ensureNetwork() {
    const chainId = await window.ethereum.request({ method: "eth_chainId" });
    const targetChainId = "0x" + this.network.chainId.toString(16);

    if (chainId !== targetChainId) {
      try {
        await window.ethereum.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: targetChainId }],
        });
      } catch (switchError) {
        // Chain not added to wallet — add it
        if (switchError.code === 4902) {
          await window.ethereum.request({
            method: "wallet_addEthereumChain",
            params: [{
              chainId: targetChainId,
              chainName: this.network.name,
              rpcUrls: [this.network.rpcUrl],
              blockExplorerUrls: [this.network.explorer],
              nativeCurrency: this.network.currency,
            }],
          });
        } else {
          throw switchError;
        }
      }
    }
  }

  _requireConnected() {
    if (!this.connected || !this.contract) {
      throw new Error("Not connected. Call connect() first.");
    }
  }

  // ─── VAULT OPERATIONS ───

  /**
   * Create a new vault
   * @param {string} ownerDID - Owner's DID string (will be hashed)
   * @param {number} checkInDays - Check-in interval in days (30-365)
   * @param {number} graceDays - Grace period in days (min 30)
   * @param {number} threshold - Guardian threshold (3-7)
   */
  async createVault(ownerDID, checkInDays = 90, graceDays = 60, threshold = 3) {
    this._requireConnected();

    const didHash = ethers.keccak256(ethers.toUtf8Bytes(ownerDID));
    const checkInSeconds = checkInDays * 24 * 60 * 60;
    const graceSeconds = graceDays * 24 * 60 * 60;

    const tx = await this.contract.createVault(
      didHash,
      checkInSeconds,
      graceSeconds,
      threshold
    );

    const receipt = await tx.wait();
    return this._parseReceipt(receipt, "VaultCreated");
  }

  /**
   * Check in (proof of life) — resets the dead man's switch
   */
  async checkIn() {
    this._requireConnected();
    const tx = await this.contract.checkIn();
    const receipt = await tx.wait();
    return this._parseReceipt(receipt, "CheckIn");
  }

  /**
   * Add a guardian
   * @param {string} guardianAddress - Guardian's wallet address
   * @param {string} shareData - The SSS share data (will be hashed for on-chain proof)
   */
  async addGuardian(guardianAddress, shareData) {
    this._requireConnected();
    const shareHash = ethers.keccak256(ethers.toUtf8Bytes(shareData));
    const tx = await this.contract.addGuardian(guardianAddress, shareHash);
    const receipt = await tx.wait();
    return this._parseReceipt(receipt, "GuardianAdded");
  }

  /**
   * Set the primary beneficiary
   * @param {string} beneficiaryAddress - Beneficiary's wallet address
   * @param {string} beneficiaryDID - Beneficiary's DID string (will be hashed)
   */
  async setBeneficiary(beneficiaryAddress, beneficiaryDID) {
    this._requireConnected();
    const identityHash = ethers.keccak256(ethers.toUtf8Bytes(beneficiaryDID));
    const tx = await this.contract.setBeneficiary(beneficiaryAddress, identityHash);
    const receipt = await tx.wait();
    return this._parseReceipt(receipt, "BeneficiarySet");
  }

  /**
   * Register an encrypted content archive (IPFS CID)
   * @param {string} cid - IPFS Content Identifier
   */
  async addContentArchive(cid) {
    this._requireConnected();
    const tx = await this.contract.addContentArchive(cid);
    const receipt = await tx.wait();
    return this._parseReceipt(receipt, "ContentArchiveAdded");
  }

  /**
   * Revoke the vault (owner only, emergency)
   */
  async revokeVault() {
    this._requireConnected();
    const tx = await this.contract.revokeVault();
    const receipt = await tx.wait();
    return this._parseReceipt(receipt, "VaultRevoked");
  }

  // ─── BENEFICIARY OPERATIONS ───

  /**
   * Submit a death certificate for oracle verification
   * @param {string} vaultOwnerAddress - Vault owner's address
   * @param {string} certificateData - Death certificate data (will be hashed)
   * @param {Uint8Array} proof - Oracle-compatible proof
   */
  async submitDeathCertificate(vaultOwnerAddress, certificateData, proof) {
    this._requireConnected();
    const certHash = ethers.keccak256(ethers.toUtf8Bytes(certificateData));
    const tx = await this.contract.submitDeathCertificate(
      vaultOwnerAddress,
      certHash,
      proof
    );
    const receipt = await tx.wait();
    return this._parseReceipt(receipt, "DeathCertificateVerified");
  }

  /**
   * Initiate a claim on a claimable vault
   * @param {string} vaultOwnerAddress - Vault owner's address
   * @param {Uint8Array} zkProof - Zero-knowledge proof of identity
   */
  async initiateClaim(vaultOwnerAddress, zkProof) {
    this._requireConnected();
    const tx = await this.contract.initiateClaim(vaultOwnerAddress, zkProof);
    const receipt = await tx.wait();
    return this._parseReceipt(receipt, "ClaimInitiated");
  }

  // ─── GUARDIAN OPERATIONS ───

  /**
   * Confirm share release (guardian only)
   * @param {string} vaultOwnerAddress - Vault owner's address
   */
  async confirmShareRelease(vaultOwnerAddress) {
    this._requireConnected();
    const tx = await this.contract.confirmShareRelease(vaultOwnerAddress);
    const receipt = await tx.wait();
    return this._parseReceipt(receipt, "GuardianConfirmed");
  }

  // ─── READ OPERATIONS (no gas) ───

  /**
   * Get vault state for any address
   */
  async getVaultState(ownerAddress = null) {
    const addr = ownerAddress || this.address;
    const state = await this.readOnlyContract.getVaultState(addr);
    return {
      code: Number(state),
      label: VAULT_STATES[Number(state)] || "Unknown",
    };
  }

  /**
   * Get time since last check-in
   */
  async getTimeSinceCheckIn(ownerAddress = null) {
    const addr = ownerAddress || this.address;
    const seconds = await this.readOnlyContract.getTimeSinceCheckIn(addr);
    return {
      seconds: Number(seconds),
      days: Number(seconds) / 86400,
      formatted: this._formatDuration(Number(seconds)),
    };
  }

  /**
   * Get guardian confirmation status
   */
  async getGuardianConfirmations(ownerAddress = null) {
    const addr = ownerAddress || this.address;
    const [confirmed, required] = await this.readOnlyContract.getGuardianConfirmations(addr);
    return {
      confirmed: Number(confirmed),
      required: Number(required),
      thresholdMet: Number(confirmed) >= Number(required),
    };
  }

  /**
   * Get content archive CIDs
   */
  async getContentArchives(ownerAddress = null) {
    const addr = ownerAddress || this.address;
    return await this.readOnlyContract.getContentArchives(addr);
  }

  /**
   * Check if a vault is claimable
   */
  async isClaimable(ownerAddress = null) {
    const addr = ownerAddress || this.address;
    return await this.readOnlyContract.isClaimable(addr);
  }

  /**
   * Check if an address has a vault
   */
  async hasVault(ownerAddress = null) {
    const addr = ownerAddress || this.address;
    return await this.readOnlyContract.hasVault(addr);
  }

  /**
   * Get full vault status summary
   */
  async getVaultSummary(ownerAddress = null) {
    const addr = ownerAddress || this.address;
    const exists = await this.hasVault(addr);
    if (!exists) return { exists: false };

    const [state, timeSince, confirmations, claimable, archives] = await Promise.all([
      this.getVaultState(addr),
      this.getTimeSinceCheckIn(addr),
      this.getGuardianConfirmations(addr),
      this.isClaimable(addr),
      this.getContentArchives(addr),
    ]);

    return {
      exists: true,
      address: addr,
      state,
      timeSinceCheckIn: timeSince,
      guardianConfirmations: confirmations,
      isClaimable: claimable,
      contentArchiveCount: archives.length,
    };
  }

  // ─── EVENT LISTENING ───

  /**
   * Subscribe to vault events
   * @param {string} eventName - Event name from contract
   * @param {Function} callback - Handler function
   */
  onEvent(eventName, callback) {
    this._requireConnected();
    this.contract.on(eventName, (...args) => {
      callback({
        event: eventName,
        args: args.slice(0, -1), // Remove event object
        log: args[args.length - 1],
      });
    });
  }

  /**
   * Subscribe to all vault events for a specific owner
   */
  onVaultEvents(ownerAddress, callback) {
    const events = [
      "CheckIn", "StateChanged", "GuardianAdded", "GuardianConfirmed",
      "BeneficiarySet", "ClaimInitiated", "SharesReleased",
      "VaultRevoked", "ContentArchiveAdded", "DeathCertificateVerified",
    ];
    events.forEach((name) => this.onEvent(name, callback));
  }

  /**
   * Remove all event listeners
   */
  removeAllListeners() {
    if (this.contract) {
      this.contract.removeAllListeners();
    }
  }

  // ─── UTILITIES ───

  _parseReceipt(receipt, expectedEvent) {
    const gasUsed = receipt.gasUsed;
    const txHash = receipt.hash;
    const blockNumber = receipt.blockNumber;

    return {
      success: receipt.status === 1,
      txHash,
      blockNumber,
      gasUsed: Number(gasUsed),
      explorerUrl: this.network.explorer
        ? `${this.network.explorer}/tx/${txHash}`
        : null,
    };
  }

  _formatDuration(seconds) {
    const days = Math.floor(seconds / 86400);
    const hours = Math.floor((seconds % 86400) / 3600);
    const mins = Math.floor((seconds % 3600) / 60);

    if (days > 0) return `${days}d ${hours}h`;
    if (hours > 0) return `${hours}h ${mins}m`;
    return `${mins}m`;
  }

  /**
   * Get wallet balance
   */
  async getBalance() {
    this._requireConnected();
    const balance = await this.provider.getBalance(this.address);
    return ethers.formatEther(balance);
  }

  /**
   * Estimate gas for an operation
   */
  async estimateGas(method, ...args) {
    this._requireConnected();
    const gas = await this.contract[method].estimateGas(...args);
    return Number(gas);
  }
}

// ============================================================
// EXPORTS
// ============================================================

export { VaultClient, VAULT_STATES, NETWORKS };
